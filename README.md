# Adherium - Patient Adherence Data Sync Service

Service that syncs inhaler usage data from mobile apps (offline-first) to a backend API, with support for idempotent event processing and adherence score calculation.

## Design Decisions

### Idempotency

My approach: each event has a unique `EventId` generated by the client at the moment the event happens (not when it's sent). The server keeps track of all event IDs it has seen using a `ConcurrentDictionary`. When a batch comes in, we simply skip any events we've already processed.

This means:
- Retries are safe - sending the same event twice won't create duplicates
- The response tells the client exactly which events were new vs already processed
- Client controls the ID, so it can persist it locally and retry with the same ID

### Adherence Calculation

The score is the percentage of puffs taken versus puffs expected, scaled from 0 to 1000. We count the total number of puffs the patient has taken and divide by how many they should have taken since their first use.

For example, if a patient started using the inhaler 3 days ago, they should have taken 12 puffs (4 per day × 3 days). If they actually took 8 puffs, their score is 8/12 = 67% = 667.

This approach ensures that every puff increases the score, giving the patient immediate feedback and motivation. The score is capped at 1000 so we don't reward overuse.

### Why Patient ID comes from the token

The request doesn't include `patientId` - we get it from the JWT. This way patients can't accidentally (or intentionally) submit events for someone else. We also validate that the `deviceId` belongs to the authenticated patient.

### Vertical Slice Architecture

I went with vertical slices instead of the traditional layered approach. Each feature lives in its own folder with everything it needs - endpoint, request/response models, handler logic.

The main win: when you need to change something, you touch one folder instead of hunting through multiple layers. It also makes the codebase easier to navigate - you look at the folder structure and immediately see what the API does.

More on this: https://www.youtube.com/watch?v=o82JG0fY_oY

### Data Access Policy

We use a simple rule to decide where data access lives:

- **Reusable logic or business rules** → `Adherium/Domain/` as a focused service (e.g. `DeviceService`, `AuthorizationService`). These services consume `AppDb` and are shared across features.
- **Feature-specific queries and projections** → `AppDb` accessed directly inside the endpoint, using LINQ `Select` to project straight into the feature's `Response` type. No mapper, no intermediate DTO.

The guiding question: *"Could another feature need this?"* If yes, it belongs in a Domain service. If no, it stays inside the feature folder.

This keeps domain logic protected without the overhead of generic repositories or redundant service abstractions.

### FastEndpoints

I chose FastEndpoints because it gives you the performance of minimal APIs with better structure. Each endpoint is a class with clear request/response types, built-in validation, and easy dependency injection. It also implements the Open Closed Principle.

Compared to MVC controllers: less ceremony, faster execution, and endpoints are self-contained. Compared to raw minimal APIs: you get validation, swagger docs, and organization out of the box.

Docs: https://fast-endpoints.com/

### Why I wrote Integration Tests

The challenge didn't ask for them, but I added integration tests anyway. Unit tests are good for logic in isolation, but they wouldn't catch issues like:
- Middleware not wired up correctly
- DI registrations missing
- Request validation not triggering
- The actual HTTP pipeline behaving differently than expected

The integration tests spin up the real API (with in-memory storage) and make actual HTTP calls. If these pass, you know the whole thing works end-to-end, not just individual pieces.

